# Правила трансформации (Transformation Rules)

Этот документ описывает правила трансформации PHP кода на этапах развёртки и свёртки.

---

## Оглавление

1. [Правила развёртки (Unfolding Rules)](#правила-развёртки-unfolding-rules)
2. [Правила свёртки (Folding/Collapsing Rules)](#правила-свёртки-foldingcollapsing-rules)

---

# Правила развёртки (Unfolding Rules)

**Развёртка** – это процесс замены всех абстракций (функций, классов, переменных) их конкретными значениями или телами.

## Общие принципы

### Принцип 1: Чистота
Трансформации применяются только к "чистым" конструкциям, которые:
- Не имеют побочных эффектов
- Детерминированы (одинаковый вход → одинаковый выход)
- Не зависят от внешнего состояния

### Принцип 2: Сохранение семантики
Любая трансформация должна сохранять исходную семантику программы. После трансформации программа должна выдавать тот же результат.

### Принцип 3: Порядок выполнения
Трансформации выполняются снизу вверх (от листьев дерева к корню) и итеративно (несколько проходов до стабилизации).

### Принцип 4: Безопасность
В случае сомнений в безопасности трансформации – она не применяется. Лучше сохранить код как есть, чем сломать его.

---

# Правила свёртки (Folding/Collapsing Rules)

Этот раздел описывает правила трансформации PHP кода на этапе свёртки. **Свёртка** – это процесс создания новых абстракций (переменных, функций) из развёрнутого кода с целью повышения читаемости и группировки операций по типу побочного эффекта.

---

## Оглавление свёртки

1. [Общие принципы свёртки](#общие-принципы-свёртки)
2. [Правила для промежуточных переменных](#правила-для-промежуточных-переменных)
3. [Правила для повторяющихся выражений](#правила-для-повторяющихся-выражений)
4. [Правила для группировки операций](#правила-для-группировки-операций)
5. [Правила для создания функций](#правила-для-создания-функций)
6. [Метрики и эвристики](#метрики-и-эвристики)

---

## Общие принципы свёртки

### Принцип 1: Читаемость
Свёртка применяется для улучшения читаемости кода. Если создание абстракции ухудшает читаемость – она не применяется.

### Принцип 2: Группировка по эффектам
Операции группируются в первую очередь по типу побочного эффекта (IO, EXTERNAL_STATE, PURE и т.д.).

### Принцип 3: Уменьшение когнитивной сложности
Основная цель – снизить когнитивную сложность кода. Каждая абстракция должна иметь понятную цель.

### Принцип 4: Минимизация абстракций
Создаём только необходимые абстракции. Избегаем over-engineering.

### Принцип 5: Сохранение семантики
Как и при развёртке, свёртка должна сохранять исходную семантику программы.

---

## Правила для промежуточных переменных

### Правило FOLD-VAR-1: Извлечение сложных выражений

**Описание:** Создание промежуточной переменной для сложного выражения, используемого в других выражениях.

**Применимо к:**
- Сложные математические выражения (>3 операций)
- Вложенные вызовы функций (глубина >2)
- Длинные строковые конкатенации (>3 операндов)

**Критерий сложности:**
- Когнитивная сложность выражения > 4
- Или выражение занимает > 80 символов
- Или выражение используется > 1 раза

**Трансформация:**

```php
// Исходный код (после развёртки)
$result = sqrt(($x * $x + $y * $y) / 2) + sqrt(($a * $a + $b * $b) / 2);

// После свёртки (шаг 1: промежуточные переменные)
$distanceXY = sqrt(($x * $x + $y * $y) / 2);
$distanceAB = sqrt(($a * $a + $b * $b) / 2);
$result = $distanceXY + $distanceAB;
```

**Именование переменных:**
- Использовать осмысленные имена, отражающие суть вычисления
- Для математических операций: использовать контекст (distance, sum, ratio и т.д.)
- Для строковых операций: использовать контекст (message, format, template и т.д.)

**Реализация:** Требует нового Visitor

**Статус:** ⏳ Не реализовано

---

### Правило FOLD-VAR-2: Консолидация связанных вычислений

**Описание:** Объединение нескольких связанных промежуточных вычислений.

**Применимо к:**
- Последовательные вычисления, использующие результаты предыдущих
- Группа вычислений, работающих с одними и теми же входными данными

**Трансформация:**

```php
// Исходный код
$temp1 = $price * 0.2;
$temp2 = $price + $temp1;
$temp3 = $temp2 * 1.1;

// После свёртки
$priceWithTax = $price * 1.2;
$finalPrice = $priceWithTax * 1.1;
// Или ещё компактнее:
$finalPrice = $price * 1.2 * 1.1;
```

**Реализация:** Требует нового Visitor

**Статус:** ⏳ Не реализовано

---

## Правила для повторяющихся выражений

### Правило FOLD-CSE-1: Common Subexpression Elimination (CSE)

**Описание:** Извлечение одинаковых подвыражений в отдельную переменную.

**Применимо к:**
- Выражение встречается ≥ 2 раз
- Выражение не содержит побочных эффектов (PURE)
- Выражение не является тривиальным (не простая переменная или константа)

**Условия:**
- Выражение детерминировано
- Используемые переменные не изменяются между использованиями
- Выражение достаточно сложное (≥ 2 операций)

**Трансформация:**

```php
// Исходный код
$area1 = $width * $height * 0.5;
$area2 = $width * $height * 0.3;
$area3 = $width * $height * 0.2;

// После свёртки (CSE)
$baseArea = $width * $height;
$area1 = $baseArea * 0.5;
$area2 = $baseArea * 0.3;
$area3 = $baseArea * 0.2;
```

**Алгоритм:**
1. Построить граф выражений
2. Найти повторяющиеся подвыражения
3. Оценить выгоду от извлечения (экономия кода vs добавление переменной)
4. Создать переменную с осмысленным именем
5. Заменить все вхождения подвыражения на переменную

**Реализация:** Требует нового Visitor

**Статус:** ⏳ Не реализовано

---

### Правило FOLD-CSE-2: Извлечение повторяющихся вызовов функций

**Описание:** Кеширование результатов повторных вызовов чистых функций с одинаковыми аргументами.

**Применимо к:**
- Функция чистая (без побочных эффектов)
- Функция вызывается ≥ 2 раз с одинаковыми аргументами
- Аргументы не изменяются между вызовами

**Трансформация:**

```php
// Исходный код
$hash1 = hash('sha256', $data) . '_suffix';
$hash2 = 'prefix_' . hash('sha256', $data);
if (hash('sha256', $data) === $expected) {
    // ...
}

// После свёртки
$dataHash = hash('sha256', $data);
$hash1 = $dataHash . '_suffix';
$hash2 = 'prefix_' . $dataHash;
if ($dataHash === $expected) {
    // ...
}
```

**Реализация:** Требует нового Visitor

**Статус:** ⏳ Не реализовано

---

## Правила для группировки операций

### Правило FOLD-GROUP-1: Группировка операций по типу эффекта

**Описание:** Группировка последовательных операций одного типа побочного эффекта.

**Применимо к:**
- Последовательность операций одного типа эффекта (IO, EXTERNAL_STATE и т.д.)
- Операции могут быть переупорядочены без изменения семантики
- Между операциями нет зависимостей

**Типы группировки:**
1. **IO операции** (echo, print, file_put_contents)
2. **Чтение внешнего состояния** ($_GET, $_POST, $_SERVER)
3. **Чистые вычисления** (математика, строки)

**Трансформация:**

```php
// Исходный код (смешанные эффекты)
$username = $_GET['username'] ?? 'guest';
echo "Processing...\n";
$userId = $_GET['id'] ?? 0;
echo "User: " . $username . "\n";
$isAdmin = ($userId === 1);
echo "Admin: " . ($isAdmin ? 'yes' : 'no') . "\n";

// После свёртки (группировка по эффектам)
// Группа 1: Чтение внешнего состояния (EXTERNAL_STATE)
$username = $_GET['username'] ?? 'guest';
$userId = $_GET['id'] ?? 0;

// Группа 2: Чистые вычисления (PURE)
$isAdmin = ($userId === 1);

// Группа 3: Вывод (IO)
echo "Processing...\n";
echo "User: " . $username . "\n";
echo "Admin: " . ($isAdmin ? 'yes' : 'no') . "\n";
```

**Алгоритм:**
1. Использовать `SideEffectSeparator` для разделения кода по эффектам
2. Использовать `EffectDependencyGraph` для проверки возможности переупорядочивания
3. Переупорядочить операции по группам эффектов
4. Добавить комментарии для обозначения групп (опционально)

**Реализация:** Использует существующие компоненты из Фазы 3, требует нового Visitor

**Статус:** ⏳ Не реализовано

---

### Правило FOLD-GROUP-2: Объединение последовательных echo

**Описание:** Объединение нескольких последовательных echo в один.

**Применимо к:**
- Последовательные вызовы echo без операций между ними
- Выводимые значения являются строками или легко приводятся к строкам

**Трансформация:**

```php
// Исходный код
echo "Hello";
echo " ";
echo "World";
echo "\n";

// После свёртки
echo "Hello World\n";
```

**Реализация:** Может быть расширением существующего функционала

**Статус:** ⏳ Частично реализовано (есть объединение echo, но можно улучшить)

---

### Правило FOLD-GROUP-3: Группировка инициализации переменных

**Описание:** Группировка инициализации связанных переменных.

**Применимо к:**
- Переменные инициализируются из одного источника данных
- Переменные имеют смысловую связь (конфигурация, координаты, параметры и т.д.)

**Трансформация:**

```php
// Исходный код
$x = $point['x'];
echo "Processing...";
$y = $point['y'];
echo "Calculating...";
$z = $point['z'];

// После свёртки
// Инициализация координат
$x = $point['x'];
$y = $point['y'];
$z = $point['z'];

// Вывод
echo "Processing...";
echo "Calculating...";
```

**Реализация:** Требует нового Visitor

**Статус:** ⏳ Не реализовано

---

## Правила для создания функций

### Правило FOLD-FUNC-1: Создание функции для чистого блока

**Описание:** Выделение большого чистого блока кода в отдельную функцию.

**Применимо к:**
- Чистый блок кода (PURE) размером ≥ 5 строк
- Блок выполняет логически завершённую операцию
- Блок может быть переиспользован

**Условия:**
- Блок не содержит побочных эффектов
- Блок имеет чёткие входы (переменные) и выход (результат)
- Блок не использует внешний контекст (кроме параметров)

**Трансформация:**

```php
// Исходный код
$dx = $x2 - $x1;
$dy = $y2 - $y1;
$distance = sqrt($dx * $dx + $dy * $dy);

$dx2 = $x3 - $x2;
$dy2 = $y3 - $y2;
$distance2 = sqrt($dx2 * $dx2 + $dy2 * $dy2);

// После свёртки
function calculateDistance($x1, $y1, $x2, $y2) {
    $dx = $x2 - $x1;
    $dy = $y2 - $y1;
    return sqrt($dx * $dx + $dy * $dy);
}

$distance = calculateDistance($x1, $y1, $x2, $y2);
$distance2 = calculateDistance($x2, $y2, $x3, $y3);
```

**Именование функций:**
- Использовать глаголы для действий: calculate, compute, format, parse и т.д.
- Имя должно отражать суть операции
- Следовать соглашениям проекта

**Реализация:** Требует нового Visitor + анализа `PureBlockFinder`

**Статус:** ⏳ Не реализовано

---

### Правило FOLD-FUNC-2: Создание функции для блока с эффектами

**Описание:** Выделение блока кода с побочными эффектами одного типа в функцию.

**Применимо к:**
- Блок кода с побочными эффектами одного типа
- Размер блока ≥ 3 строк
- Блок выполняет логически завершённую операцию

**Трансформация:**

```php
// Исходный код
echo "=== Report ===\n";
echo "User: " . $username . "\n";
echo "Status: " . $status . "\n";
echo "===============\n";

// Другой код...

echo "=== Report ===\n";
echo "User: " . $otherUsername . "\n";
echo "Status: " . $otherStatus . "\n";
echo "===============\n";

// После свёртки
function printReport($username, $status) {
    echo "=== Report ===\n";
    echo "User: " . $username . "\n";
    echo "Status: " . $status . "\n";
    echo "===============\n";
}

printReport($username, $status);
// Другой код...
printReport($otherUsername, $otherStatus);
```

**Реализация:** Требует нового Visitor

**Статус:** ⏳ Не реализовано

---

## Метрики и эвристики

### Метрика 1: Когнитивная сложность выражения

Оценка сложности выражения для принятия решения о создании промежуточной переменной:

- **Простое** (0-2 балла): `$x + $y`, `$arr[0]`, `strlen($str)`
- **Среднее** (3-5 баллов): `$x * $y + $z`, `$arr[$key]['value']`, `hash('sha256', $data)`
- **Сложное** (6+ баллов): `sqrt($x * $x + $y * $y)`, вложенные вызовы функций

**Критерии начисления баллов:**
- Каждая бинарная операция: +1 балл
- Каждый вызов функции: +2 балла
- Каждый уровень вложенности: +1 балл
- Каждый доступ к массиву/свойству: +1 балл

**Порог для создания переменной:** ≥ 4 балла

---

### Метрика 2: Частота использования подвыражения

Оценка целесообразности CSE (Common Subexpression Elimination):

- **Используется 1 раз:** Не извлекать
- **Используется 2 раза:** Извлекать, если сложность ≥ 3
- **Используется 3+ раз:** Всегда извлекать

**Формула выгоды:**
```
benefit = (frequency - 1) * complexity - overhead
где:
  frequency = количество использований
  complexity = сложность выражения (баллы)
  overhead = стоимость создания переменной (обычно 2)
```

Если `benefit > 0`, то CSE выгоден.

---

### Метрика 3: Размер блока для создания функции

Минимальные требования для выделения блока в функцию:

| Тип блока | Мин. размер | Мин. сложность | Мин. повторения |
|-----------|-------------|----------------|-----------------|
| PURE | 5 строк | 10 баллов | 1 раз |
| IO | 3 строки | 5 баллов | 2 раза |
| EXTERNAL_STATE | 3 строки | 5 баллов | 2 раза |
| MIXED | 7 строк | 15 баллов | 1 раз |

**Сложность блока** = сумма сложностей всех выражений в блоке.

---

### Эвристика 1: Порог длины строки

Если строка кода > 80 символов и содержит сложное выражение – рекомендуется создание промежуточной переменной.

---

### Эвристика 2: Семантическая близость

При группировке операций учитывать семантическую близость:

1. **Высокая близость** (всегда группировать):
   - Инициализация связанных переменных (x, y, z координаты)
   - Чтение параметров из одного источника ($_GET, $_POST)
   - Последовательные IO операции для одного сообщения

2. **Средняя близость** (группировать при возможности):
   - Операции одного типа эффекта
   - Вычисления для одного домена (price, tax, discount)

3. **Низкая близость** (не группировать):
   - Разные домены данных
   - Разные типы побочных эффектов

---

### Эвристика 3: Именование переменных

При создании промежуточных переменных использовать семантически значимые имена:

**Шаблоны именования:**
- Математические операции: `{context}{Operation}` (e.g., `priceTotal`, `distanceEuclidean`)
- Строковые операции: `{context}{Format}` (e.g., `messageFormatted`, `nameNormalized`)
- Промежуточные результаты: `{context}{State}` (e.g., `dataProcessed`, `userValidated`)
- Флаги: `is{Condition}`, `has{Property}` (e.g., `isValid`, `hasPermission`)

**Антипаттерны (избегать):**
- `$temp1`, `$temp2`, `$tmp`
- `$var`, `$result`, `$data` (слишком общие)
- `$a`, `$b`, `$c` (неинформативные)

---

## Критерии применимости правил

Для каждого правила определяются:

1. **Безопасность** (Safety): насколько безопасно применять правило
   - ✅ Безопасно: результат гарантированно эквивалентен
   - ⚠️ Условно безопасно: безопасно при соблюдении условий
   - ❌ Небезопасно: может изменить семантику

2. **Целесообразность** (Value): насколько правило улучшает код
   - ⭐⭐⭐ Значительное улучшение читаемости
   - ⭐⭐ Среднее улучшение
   - ⭐ Небольшое улучшение

3. **Приоритет** (Priority): порядок применения
   - 1: Критичные правила, применяются в первую очередь
   - 2: Важные правила, применяются во вторую очередь
   - 3: Дополнительные правила, применяются по необходимости

### Сводная таблица правил свёртки

| Правило | Безопасность | Ценность | Приоритет |
|---------|--------------|----------|-----------|
| FOLD-VAR-1 | ✅ | ⭐⭐⭐ | 1 |
| FOLD-VAR-2 | ✅ | ⭐⭐ | 2 |
| FOLD-CSE-1 | ✅ | ⭐⭐⭐ | 1 |
| FOLD-CSE-2 | ✅ | ⭐⭐⭐ | 1 |
| FOLD-GROUP-1 | ⚠️ | ⭐⭐⭐ | 1 |
| FOLD-GROUP-2 | ✅ | ⭐⭐ | 2 |
| FOLD-GROUP-3 | ✅ | ⭐⭐ | 2 |
| FOLD-FUNC-1 | ✅ | ⭐⭐⭐ | 2 |
| FOLD-FUNC-2 | ⚠️ | ⭐⭐ | 3 |

**Приоритет:**
- 1: Правила для переменных и CSE – применяются первыми
- 2: Правила для группировки и простых функций
- 3: Правила для сложных функций с побочными эффектами

---

## Порядок применения правил свёртки

Рекомендуемый порядок применения правил свёртки:

1. **Фаза 1: Common Subexpression Elimination**
   - FOLD-CSE-1: Извлечение повторяющихся подвыражений
   - FOLD-CSE-2: Извлечение повторяющихся вызовов функций

2. **Фаза 2: Создание промежуточных переменных**
   - FOLD-VAR-1: Извлечение сложных выражений
   - FOLD-VAR-2: Консолидация связанных вычислений

3. **Фаза 3: Группировка операций**
   - FOLD-GROUP-1: Группировка по типу эффекта
   - FOLD-GROUP-3: Группировка инициализации переменных
   - FOLD-GROUP-2: Объединение последовательных echo

4. **Фаза 4: Создание функций**
   - FOLD-FUNC-1: Создание функций для чистых блоков
   - FOLD-FUNC-2: Создание функций для блоков с эффектами

---

## Заключение по свёртке

Правила свёртки предназначены для создания читаемого, хорошо структурированного кода из развёрнутого. Основные цели:

1. **Повышение читаемости** – создание осмысленных абстракций
2. **Группировка по эффектам** – разделение кода по типу побочного эффекта
3. **Уменьшение дублирования** – извлечение повторяющихся выражений
4. **Снижение когнитивной сложности** – упрощение сложных выражений

При реализации новых правил свёртки необходимо:

1. Добавить описание правила в этот документ
2. Реализовать Visitor для применения правила
3. Написать unit-тесты для правила
4. Добавить feature-тесты на реальных примерах
5. Интегрировать с существующими компонентами (SideEffectSeparator, EffectDependencyGraph, PureBlockFinder)
6. Обновить roadmap

Все правила свёртки должны строго следовать принципам сохранения семантики и улучшения читаемости кода.
